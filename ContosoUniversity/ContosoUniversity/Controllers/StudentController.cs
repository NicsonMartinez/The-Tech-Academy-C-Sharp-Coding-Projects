using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Entity;
using System.Linq;
using System.Net;
using System.Web;
using System.Web.Mvc;
using ContosoUniversity.DAL;
using ContosoUniversity.Models;
using PagedList; //NOTE: I added this after installing 'PagedList.Mvc' through NuGet by typing command, Install-Package PagedList.Mvc in the 'Package Manager Console'.


/*NOTE: This class was auto-generated by doing the follwing:
        1. Right-click the Controllers folder in Solution Explorer, select 'Add', and then click 'New Scaffolded Item...'.
        2. In the Add Scaffold dialog box, select 'MVC 5 Controller with views, using Entity Framework', and then choose 'Add'.
        3. In the Add Controller dialog box, make the following selections, and then choose Add:
            - Model class: Student (ContosoUniversity.Models). (If you don't see this option in the drop-down list, build the project and try again.)
            - Data context class: SchoolContext (ContosoUniversity.DAL).
            - Controller name: StudentController (not StudentsController).
            - Leave the default values for the other fields.

        When you click 'Add', the scaffolder creates a 'StudentController.cs' file (This current file) and a set 
        of views (.cshtml files) that work with the controller (a 'Student' folder under 'Views' containing 'Create.cshtml', 
        'Delete.cshtml', 'DEtails.cshtml', 'Edit.cshtml', and 'Index.cshtml'). 

        In the future when you create projects that use Entity Framework, you can also take advantage of some additional 
        functionality of the scaffolder: create your first model class, don't create a connection string, and then in the
        Add Controller box specify New data context by selecting the + button next to Data context class. 
        The scaffolder will create your DbContext class and your connection string as well as the controller and views.   
*/


namespace ContosoUniversity.Controllers
{
    public class StudentController : Controller
    {
        private SchoolContext db = new SchoolContext();

        // GET: Student
        //public ActionResult Index()
        //{
        //    return View(db.Students.ToList());
        //}

        //NOTE: This code adds a 'page' parameter, a current sort order parameter, and a current filter parameter to the method signature:
        /*NOTE: The first time the page is displayed, or if the user hasn't clicked a paging or sorting link, all the parameters are null. 
         *      If a paging link is clicked, the 'page' variable contains the page number to display.*/
        public ActionResult Index(string sortOrder, string currentFilter, string searchString, int? page)
        {
            /*NOTE: A ViewBag property provides the view with the current sort order, because this must be included in the 
             *      paging links in order to keep the sort order the same while paging:*/
            ViewBag.CurrentSort = sortOrder;

            //NOTE: Here We are saying if the url shows 'http://localhost:51086/Student', that means sortOrder is 'null'
            //      which means at that point (right after that request) LastName is in ascending order (by default). When the user
            //      clicks on the 'LastName' ActionLink, the user wants to turn it from ascending to descending order. That's why
            //      the code below is assigning ViewBag.NameSortParm the value of 'name_desc' once that ActonLink is clicked for the first time.
            //      At this point the url will show 'http://localhost:51086/Student?sortOrder=name_desc' which means the list is in 
            //      descending order. Thus, before the user decides to click that 'ActionLink' again, the 'String.IsNullOrEmpty(sortOrder)' will 
            //      be false and ViewBag.NameSortParm will be assigned to "", which means after the user clicks it, it will just do the 
            //      default behavior again which is to order in ascending order.
            ViewBag.NameSortParm = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";

            //NOTE: This follows a similar logic as above, except the first time the user clicks the ViewBag.DateSortParm 'ActionLink'
            //      the url will whow 'http://localhost:51086/Student?sortOrder=Date' and the page will show 'EnrollmentDate' in ascending
            //      order. Before the user clicks it again, the value in ViewBag.DateSortParm has already changed to "date_desc" becuase \
            //      sortOrder == "Date" equated to 'true'. After the user clicks that ActionLink again it the url will show 
            //      'http://localhost:51086/Student?sortOrder=date_desc' and the list will be shown in descending order.
            //NOTE: Basically the url pattern changes on one link or another depending on what was clicked prior.
            ViewBag.DateSortParm = sortOrder == "Date" ? "date_desc" : "Date";

            /*NOTE: The 'ViewBag.CurrentFilter' provides the view with the current filter string. This value must be included 
             *      in the paging links in order to maintain the filter settings during paging, and it must be restored to the text box when the 
             *      page is redisplayed. If the search string is changed during paging, the page has to be reset to 1, because the new filter can 
             *      result in different data to display. The search string is changed when a value is entered in the text box and the submit button 
             *      is pressed. In that case, the searchString parameter is not null.*/
            if (searchString != null)
            {
                page = 1;
            }
            else
            {
                searchString = currentFilter;
            }
            ViewBag.CurrentFilter = searchString;


            var students = from s in db.Students
                           select s;

            /*NOTE: The code adds a searchString parameter to the Index method. The search string value is received from a text 
             *      box that you'll add to the Index view. It also adds a where clause to the LINQ statement that selects only 
             *      students whose first name or last name contains the search string. The statement that adds the Where clause 
             *      executes only if there's a value to search for.*/
            if (!String.IsNullOrEmpty(searchString))
            {
                students = students.Where(s => s.LastName.Contains(searchString)
                                       || s.FirstMidName.Contains(searchString));
            }

            switch (sortOrder)
            {
                case "name_desc":
                    students = students.OrderByDescending(s => s.LastName);
                    break;
                case "Date":
                    students = students.OrderBy(s => s.EnrollmentDate);
                    break;
                case "date_desc":
                    students = students.OrderByDescending(s => s.EnrollmentDate);
                    break;
                default:
                    students = students.OrderBy(s => s.LastName);
                    break;
            }
            //return View(students.ToList());

            //NOTE: This is where we set how many queried table rows we want to show per page.
            int pageSize = 4;

            /*NOTE: The ToPagedList extension method on the students IQueryable object below converts the student 
             *      query to a single page of students in a collection type that supports paging. That single page of students is then 
             *      passed to the view:*/
            int pageNumber = (page ?? 1); //NOTE: Assign 'page' to 'pageNumber' but, if 'page' is null, then assign 1 to 'pageNumber'.
            return View(students.ToPagedList(pageNumber, pageSize));
        }


        // GET: Student/Details/5
        public ActionResult Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            Student student = db.Students.Find(id);
            if (student == null)
            {
                return HttpNotFound();
            }
            return View(student);
        }

        // GET: Student/Create
        public ActionResult Create()
        {
            return View();
        }

        // POST: Student/Create
        // To protect from overposting attacks, please enable the specific properties you want to bind to, for 
        // more details see https://go.microsoft.com/fwlink/?LinkId=317598.
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Create([Bind(Include = "ID,LastName,FirstMidName,EnrollmentDate")] Student student)
        {
            try
            {
                if (ModelState.IsValid)
                {
                    db.Students.Add(student);
                    db.SaveChanges();
                    return RedirectToAction("Index");
                }
            }
            catch (DataException /* dex */)
            {
                //Log the error (uncomment dex variable name and add a line here to write a log.
                ModelState.AddModelError("", "Unable to save changes. Try again, and if the problem persists see your system administrator.");
            }
            return View(student);
        }

        //GET: Student/Edit/5
        public ActionResult Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            Student student = db.Students.Find(id);
            if (student == null)
            {
                return HttpNotFound();
            }
            return View(student);
        }

       

        // POST: Student/Edit/5
        // To protect from overposting attacks, please enable the specific properties you want to bind to, for 
        // more details see https://go.microsoft.com/fwlink/?LinkId=317598.
        //[HttpPost]
        //[ValidateAntiForgeryToken]
        //public ActionResult Edit([Bind(Include = "ID,LastName,FirstMidName,EnrollmentDate")] Student student)
        //{
        //    if (ModelState.IsValid)
        //    {
        //        db.Entry(student).State = EntityState.Modified;
        //        db.SaveChanges();
        //        return RedirectToAction("Index");
        //    }
        //    return View(student);
        //}

        //NOTE: The code commented above was replaced by the code below.

        [HttpPost, ActionName("Edit")]
        [ValidateAntiForgeryToken]
        public ActionResult EditPost(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            var studentToUpdate = db.Students.Find(id);
            if (TryUpdateModel(studentToUpdate, "",
               new string[] { "LastName", "FirstMidName", "EnrollmentDate" }))
            {
                try
                {
                    db.SaveChanges();

                    return RedirectToAction("Index");
                }
                catch (DataException /* dex */)
                {
                    //Log the error (uncomment dex variable name and add a line here to write a log.
                    ModelState.AddModelError("", "Unable to save changes. Try again, and if the problem persists, see your system administrator.");
                }
            }
            return View(studentToUpdate);
        }

        /*NOTE: These changes (above) implement a security best practice to prevent overposting, The scaffolder generated a Bind attribute 
         *      and added the entity created by the model binder to the entity set with a Modified flag. That code is no longer recommended  
         *      because the Bind attribute clears out any pre-existing data in fields not listed in the Include parameter. In the future, 
         *      the MVC controller scaffolder will be updated so that it doesn't generate Bind attributes for Edit methods.

         *      The new code reads the existing entity and calls TryUpdateModel to update fields from user input in the posted form data. 
         *      The Entity Framework's automatic change tracking sets the EntityState.Modified flag on the entity. When the SaveChanges 
         *      method is called, the Modified flag causes the Entity Framework to create SQL statements to update the database row. 
         *      Concurrency conflicts are ignored, and all columns of the database row are updated, including those that the user didn't 
         *      change. (A later tutorial shows how to handle concurrency conflicts, and if you only want individual fields to be updated 
         *      in the database, you can set the entity to EntityState.Unchanged and set individual fields to EntityState.Modified.)

         *      To prevent overposting, the fields that you want to be updateable by the Edit page are whitelisted in the TryUpdateModel 
         *      parameters. Currently there are no extra fields that you're protecting, but listing the fields that you want the model 
         *      binder to bind ensures that if you add fields to the data model in the future, they're automatically protected until you 
         *      explicitly add them here.

         *      As a result of these changes, the method signature of the HttpPost Edit method is the same as the HttpGet edit method; 
         *      therefore you've renamed the method EditPost.         
         */




        /*NOTE: As noted, the 'HttpGet' 'Delete' method (below) doesn't delete the data. Performing a delete operation in response
         *      to a GET request (or for that matter, performing any edit operation, create operation, or any other 
        *      operation that changes data) creates a security risk. For more information, see 
        *      'ASP.NET MVC Tip #46 — Don't use Delete Links because they create Security Holes' on Stephen Walther's blog:
        *      http://stephenwalther.com/archive/2009/01/21/asp-net-mvc-tip-46-ndash-donrsquot-use-delete-links-because
        */

        // GET: Student/Delete/5
        public ActionResult Delete(int? id, bool? saveChangesError=false)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            if (saveChangesError.GetValueOrDefault())
            {
                ViewBag.ErrorMessage = "Delete failed. Try again, and if the problem persists see your system administrator.";
            }
            Student student = db.Students.Find(id);
            if (student == null)
            {
                return HttpNotFound();
            }
            return View(student);
        }

        /*NOTE: This code (above) accepts an optional parameter that indicates whether the method was called after a failure  
         *      to save changes. This parameter is 'false' when the 'HttpGet' 'Delete' method is called without a previous failure.  
         *      When it is called by the 'HttpPost' 'Delete' method ('DeleteConfirmed' method below) in response to a database 
         *      update error, the parameter is true and an error message is passed to the view.
         */

        // POST: Student/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public ActionResult DeleteConfirmed(int id)
        {
            try
            {
                //Student student = db.Students.Find(id);
                //db.Students.Remove(student);
                
                /*NOTE: If improving performance in a high-volume application is a priority, you could avoid an unnecessary 
                 * SQL query to retrieve the row by replacing the lines of code that call the 'Find' and 'Remove' methods  
                 * from the commented code above with the following code:*/
                Student studentToDelete = new Student() { ID = id };
                db.Entry(studentToDelete).State = EntityState.Deleted;
                /*NOTE: This code (above) instantiates a Student entity using only the primary key value and then sets the 
                 *      entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.*/

                db.SaveChanges();
            }
            catch (DataException/* dex*/)
            {
                //Log the error (uncomment dex variable name and add a line here to write a log.
                return RedirectToAction("Delete", new { id = id, saveChangesError = true });
            }
            return RedirectToAction("Index");
        }


        /*NOTE: To close database connections and free up the resources they hold as soon as possible, dispose the context 
         *      instance when you are done with it. That is why the scaffolded code provides a Dispose method at the end 
         *      of this StudentController class in StudentController.cs, as shown in the code below:*/
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                db.Dispose();
            }
            base.Dispose(disposing);
        }
    }
}
